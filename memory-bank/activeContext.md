# 当前上下文

## 当前工作焦点

- **任务**: 修复 `gemini-to-gemini` 路由中工具调用（Tool Calling）失败的问题，并统一系统适配器的设计原则。
- **状态**: 已完成。

## 调查与根本原因分析

1.  **初始问题**: 用户报告，通过 `gemini-to-gemini` 路由的工具调用失败，客户端收到了纯文本（如 `<write_file>...</write_file>`）而非结构化的工具调用指令。
2.  **错误诊断过程**:
    - 初步调查指向了 `openai-to-gemini` 的工具转换缺失，但用户澄清问题核心在于 `gemini-to-gemini`。
    - 多次尝试修改 `gemini-to-gemini` 的 `transformRequest` 和 `transformStream` 函数，但因对设计意图的误解而被拒绝。
3.  **最终共识与根本原因**:
    - 通过与用户的深入沟通，明确了系统的核心设计原则：**所有适配器（Adapter）都必须履行“清洗和规范化”数据的职责，不能为了效率而盲目“透传”**。
    - 根本原因被确定为 `gemini-to-gemini` 适配器违反了此原则。其“透传”模式导致了两个问题：
      - **请求端**: 不规范的客户端请求被直接发送到下游，可能导致 Gemini API 无法正确识别工具意图，从而“降级”为文本生成。
      - **响应端**: 对从 SDK 返回的复杂类实例直接使用 `JSON.stringify`，存在被其自定义 `toJSON()` 方法影响的风险，可能导致结构化数据（如 `functionCall`）被意外序列化为文本。

## 解决方案

为了使 `gemini-to-gemini` 适配器的行为与系统设计原则保持一致，并确保其健壮性，执行了以下重构：

1.  **废除“透传”模式**:
    - **`transformRequest`**: 重写了此函数，现在它会显式地从原始请求中提取已知属性，构建一个全新的、干净的、规范化的请求对象，再传递给核心通信层。
    - **`transformResponse` / `transformStream`**: 增加了一个 `toPlainObject` 辅助函数。此函数在序列化（`JSON.stringify`）之前，会递归地将 SDK 返回的响应对象（`chunk`）转换为一个纯粹的 JavaScript 对象，从而剥离任何可能干扰标准序列化行为的类方法或原型，确保了 `functionCall` 等结构化数据的完整性。

## 下一步

- **任务**: 等待新的任务分配。
